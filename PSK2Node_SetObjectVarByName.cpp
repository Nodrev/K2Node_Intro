// Copyright Nicholas Ferrar 2019


#include "PSK2Node_SetObjectVarByName.h"

#include "PSData.h"

#include "EdGraphSchema_K2.h"

#include "KismetCompiler.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "K2Node_CallFunction.h"

#define LOCTEXT_NAMESPACE "PSK2Node_SetObjectVarByName"

struct FGetPinName
{

	static const FName& GetTargetPinName()
	{
		static const FName TargetPinName(TEXT("Target"));
		return TargetPinName;
	}

	static const FName& GetVarNamePinName()
	{
		static const FName VarNamePinName(TEXT("VarName"));
		return VarNamePinName;
	}

	static const FName& GetNewValuePinName()
	{
		static const FName NewValuePinName(TEXT("NewValue"));
		return NewValuePinName;
	}

	static const FName& GetOutputResultPinName()
	{
		static const FName OutputResultPinName(TEXT("bSuccess"));
		return OutputResultPinName;
	}

	static const FName& GetOutputValuePinName()
	{
		static const FName OutputValuePinName(TEXT("NewValueResult"));
		return OutputValuePinName;
	}
};

namespace FSetterFunctionNames
{
	static const FName FloatSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetFloatByName));
	static const FName IntSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetIntByName));
	static const FName Int64SetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetInt64ByName));
	static const FName BoolSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetBoolByName));
	static const FName NameSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetNameByName));
	static const FName ObjectSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetObjectByName));
	static const FName ClassSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetClassByName));
	static const FName ByteSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetByteByName));
	static const FName StringSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetStringByName));
	static const FName TextSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetTextByName));
	static const FName StructSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetStructByName));
	static const FName EnumSetterName(GET_FUNCTION_NAME_CHECKED(UPSData, SetEnumByName));
};

void UPSK2Node_SetObjectVarByName::AllocateDefaultPins()
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	/*Create our pins*/

	// Execution pins
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

	//Input
	UEdGraphNode::FCreatePinParams PinParams;
	PinParams.bIsReference = true;

	UEdGraphPin* InTargetPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, UObject::StaticClass(), FGetPinName::GetTargetPinName(), PinParams);
	UEdGraphPin* InVarNamePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, FGetPinName::GetVarNamePinName());
	K2Schema->SetPinAutogeneratedDefaultValue(InVarNamePin, FName("My Var Name").ToString());
	UEdGraphPin* InNewValuePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, FGetPinName::GetNewValuePinName(), PinParams);

	//Output
	UEdGraphPin* OutValidPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, FGetPinName::GetOutputResultPinName());
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(OutValidPin);
	UEdGraphPin* OutNewValuePin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, FGetPinName::GetOutputValuePinName());

	Super::AllocateDefaultPins();
}

void UPSK2Node_SetObjectVarByName::PinDefaultValueChanged(UEdGraphPin * Pin)
{
	if (Pin)
	{
		if (Pin->PinName == FGetPinName::GetNewValuePinName())
		{
			GetReturnValuePin()->PinType = Pin->PinType;
		}
	}
}

///These three functions make the node appear as an option;

FText UPSK2Node_SetObjectVarByName::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("SetObjVarByNameK2Node_Title", "Set Object Variable By Name");
}

FText UPSK2Node_SetObjectVarByName::GetTooltipText() const
{
	return LOCTEXT("SetObjVarByNameK2Node_Tooltip", "Sets the value of a variable in a provided object. Takes in the target object and the name of the variable to be changed, then sets the value to the provided New Value.");
}

FText UPSK2Node_SetObjectVarByName::GetMenuCategory() const
{
	return LOCTEXT("SetObjVarByNameK2Node_MenuCategory", "nfPopulationSystem");
}

///end

void UPSK2Node_SetObjectVarByName::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UFunction* BlueprintFunction = FindSetterFunctionByType(GetNewValuePin()->PinType);

	if (!BlueprintFunction)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "The function has not been found.").ToString(), this);
		return;
	}

	UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	CallFunction->SetFromFunction(BlueprintFunction);
	CallFunction->AllocateDefaultPins();
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

	//Input
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetTargetPinName()), *CallFunction->FindPinChecked(TEXT("Target")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetVarNamePinName()), *CallFunction->FindPinChecked(TEXT("VarName")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetNewValuePinName()), *CallFunction->FindPinChecked(TEXT("NewValue")));

	//Output
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetOutputValuePinName()), *CallFunction->FindPinChecked(TEXT("OutValue")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(FGetPinName::GetOutputResultPinName()), *CallFunction->GetReturnValuePin());

	//Exec pins
	UEdGraphPin* NodeExec = GetExecPin();
	UEdGraphPin* NodeThen = FindPin(UEdGraphSchema_K2::PN_Then);

	UEdGraphPin* InternalExec = CallFunction->GetExecPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeExec, *InternalExec);

	UEdGraphPin* InternalThen = CallFunction->GetThenPin();
	CompilerContext.MovePinLinksToIntermediate(*NodeThen, *InternalThen);

	//After we are done we break all links to this node (not the internally created one)
	BreakAllNodeLinks();
}

//This method adds our node to the context menu
void UPSK2Node_SetObjectVarByName::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	Super::GetMenuActions(ActionRegistrar);

	UClass* Action = GetClass();

	if (ActionRegistrar.IsOpenForRegistration(Action))
	{
		UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
		check(Spawner != nullptr);

		ActionRegistrar.AddBlueprintAction(Action, Spawner);
	}
}

void UPSK2Node_SetObjectVarByName::NotifyPinConnectionListChanged(UEdGraphPin * Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	UEdGraphPin* NewValuePin = GetNewValuePin();
	UEdGraphPin* OutValuePin = GetReturnValuePin();

	if ((Pin == NewValuePin) || (Pin == OutValuePin))
	{
		UEdGraphPin* ConnectedToPin = (Pin->LinkedTo.Num() > 0) ? Pin->LinkedTo[0] : NULL;
		CoerceTypeFromPin(ConnectedToPin, Pin == NewValuePin ? true : false);
	}
}

///Pin getters

UEdGraphPin * UPSK2Node_SetObjectVarByName::GetThenPin() const
{
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	UEdGraphPin* Pin = FindPinChecked(UEdGraphSchema_K2::PN_Then);
	check(Pin->Direction == EGPD_Output);
	return Pin;
}

UEdGraphPin * UPSK2Node_SetObjectVarByName::GetTargetPin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName::GetTargetPinName());
	check(Pin == NULL || Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin * UPSK2Node_SetObjectVarByName::GetVarNamePin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName::GetVarNamePinName());
	check(Pin == NULL || Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin * UPSK2Node_SetObjectVarByName::GetNewValuePin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName::GetNewValuePinName());
	check(Pin == NULL || Pin->Direction == EGPD_Input);
	return Pin;
}

UEdGraphPin * UPSK2Node_SetObjectVarByName::GetReturnResultPin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName::GetOutputResultPinName());
	check(Pin == NULL || Pin->Direction == EGPD_Output);
	return Pin;
}

UEdGraphPin * UPSK2Node_SetObjectVarByName::GetReturnValuePin() const
{
	UEdGraphPin* Pin = FindPin(FGetPinName::GetOutputValuePinName());
	check(Pin == NULL || Pin->Direction == EGPD_Output);
	return Pin;
}

///Node type handling

void UPSK2Node_SetObjectVarByName::CoerceTypeFromPin(const UEdGraphPin * Pin, bool bWasNewValuePin)
{
	UEdGraphPin* InValuePin = GetNewValuePin();
	UEdGraphPin* OutValuePin = GetReturnValuePin();

	check(InValuePin && OutValuePin);

	if (Pin)
	{
		check((Pin != InValuePin) || (Pin->PinType.bIsReference && !Pin->PinType.IsContainer()));

		InValuePin->PinType = Pin->PinType;
		InValuePin->PinType.bIsReference = true;

		OutValuePin->PinType = Pin->PinType;
		OutValuePin->PinType.bIsReference = false;
	}
	else
	{
		// Pin disconnected...revert to wildcard
		if (bWasNewValuePin)
		{
			InValuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			InValuePin->PinType.PinSubCategory = NAME_None;
			InValuePin->PinType.PinSubCategoryObject = nullptr;
			InValuePin->BreakAllPinLinks();

			OutValuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			OutValuePin->PinType.PinSubCategory = NAME_None;
			OutValuePin->PinType.PinSubCategoryObject = nullptr;
			OutValuePin->BreakAllPinLinks();
		}
		else if (InValuePin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
		{
			OutValuePin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			OutValuePin->PinType.PinSubCategory = NAME_None;
			OutValuePin->PinType.PinSubCategoryObject = nullptr;
			OutValuePin->BreakAllPinLinks();
		}
	}
}

///Finders

//find setter
UFunction * UPSK2Node_SetObjectVarByName::FindSetterFunctionByType(FEdGraphPinType& PinType)
{
	UClass* LibraryClass = UPSData::StaticClass();
	FName FunctionName = NAME_None;
	UFunction* Function = nullptr;

	//this should really be in a const FNAME
	//here goes a bunch of IFs to check the pin type and set FUNCTION NAME to its NAME
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Float)
	{
		FunctionName = FSetterFunctionNames::FloatSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Int)
	{
		FunctionName = FSetterFunctionNames::IntSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Int64)
	{
		FunctionName = FSetterFunctionNames::Int64SetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Boolean)
	{
		FunctionName = FSetterFunctionNames::BoolSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Name)
	{
		FunctionName = FSetterFunctionNames::NameSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Object)
	{
		FunctionName = FSetterFunctionNames::ObjectSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Class)
	{
		FunctionName = FSetterFunctionNames::ClassSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Byte)
	{
		FunctionName = FSetterFunctionNames::ByteSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_String)
	{
		FunctionName = FSetterFunctionNames::StringSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Text)
	{
		FunctionName = FSetterFunctionNames::TextSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Struct)
	{
		FunctionName = FSetterFunctionNames::StructSetterName;
	}
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Enum)
	{
		FunctionName = FSetterFunctionNames::EnumSetterName;
	}

	if (!FunctionName.IsNone())
	{
		Function = LibraryClass->FindFunctionByName(FunctionName);
	}

	return Function;
}

#undef LOCTEXT_NAMESPACE